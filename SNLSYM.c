#include<stdio.h>
int state[200];//语法栈
int cur;//语法栈栈顶
int fsem;//未处理函数栈
//{
//	Arg *argpt;// 指向相应ARG结构
//	sem *before;//sem栈内容
//}sem
//sem  *head; // 语义栈头指针
//sem  *semcur;//语义栈当前指针
arg *sem[20];//采用数组实现语义栈

/*                          语法语义及产生中间代码函数       */
void symtest(/*token链表指针*/)
{
	int a;         //临时变量
	int choproduct[/*终极和非终极符个数*/][/*产生式个数*/];
	int product[/*产生式个数*/][10]；
	while(state[cur]!=/*结束状态*/)
	{
		if(p==null)
		{
			/* 报错*/
		}
		tokentemp=choproduct[state[cur]][token.lex];//根据LL（1）表选择产生式对应编号
		for(i=0;product[tokentemp][i]!=/*产生式语法部分结束符*/;i++)
			state[cur++]=product[tokentemp][i];//更新语法栈内容 
		a=product[tokentemp][10];//根据产生式末尾编号选择对应数组函数
		dealpro[a](/*参数情况待定*/);//相应产生式处理函数
		///////////////////其他内容/////////////////////
		//检查为处理函数栈是否可以执行————————————————————————————important

		///////////////////////////////////////////////
		p=p.next;
	}
}
///////////////////////////产生式函数原则：！！！！！！！！！只需对语义栈元素操作/////////////////////////////////////

void dealpro[/*66,92,73*/](	)   //功能：ID压语义栈
{	
	arg *parg;
	parg=malloc(/*   */);// 将指针压栈
	while(level!=0)
	{
		cmpstr(,token.sym);//查找符号
		IDtabPt=IDtabPt->next;
		if(IDtabPt->next==null)
		{
			level=level-1;
			IDtabPt=scope[level];
		}
	}
	parg->form=1;// valueform 1 ; labelform 2 ; addrform 3;
	parg->label=IDtabPt->name;
	parg->datalevel=IDtabPt->level;
	parg->dataoff=IDtabPt->off;
	access=1;    // dir 1; indir 2;
	psem=malloc(/*  */);
	psem->before=semcur;//尚未对semcur处理
	psem->argpt=parg;//现在psem为语义栈栈顶
	
			
}
//////////////////////////////////////////////////赋值语句处理函数/////////////////////////////////////////////////////////////////
void dealpro[/*69  */](		)
{
	//将产生！！！！赋值！！！中间代码函数编号压栈 （ADD，SEM【CUR】，SEM【CUR-1】null ）    屌 只对栈操作 巨屌～～ 
	//产生代码
	//删除栈顶头两个元素
}

void dealpro[/* 103 */](	)
{
	//将产生 ！！！MULTI！！中间代码函数压栈 (multi,sem[cur],sem[cur-1],temp[i++])
	//temp[i]替换栈顶头两个元素
}

void dealprol[/* 101  */](		)
{
	//略同 103   ！ADD  ！！。。。。
}
/////////////////////////////////////        if 语句处理函数 //////////////////////////////////////////////////////////////////////////////////////
void dealpro[/* 70 ]*/](	)
{
	//将产生中间代码(LABEL,........  )函数压栈
}


void dealpro[/* 109 */](	)
{
	//产生中间代码(JUMP0,....)
	// 将产生中间代码（JUMP，) 函数 压栈
	//               （LABEL，。。）
}

void dealpro[/* 110 */](	)
{
	//设置执行函数参数及标记，并执行为处理函数栈中的选定函数,for example a=向后处理函数栈中函数个数
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////while 语句处理函数 /////////////////////////////////////////////////////

void dealpro[/*71  */](		)
{
	//产生中间代码(LABEL,....)
	//将产生中间代码(JUMP,START.....)函数压栈
	//		(LABEL,OUT....)
}


void dealpro[/* 111 */](	)	
{
	//产生中间代码(JUMP0,EARG...............)
	//设置向后执行函数个数
}


///////////////////////////////////////过程调用语句//////////////////////////////////////////////////////

void dealpro[/* 76  */](		)
{
	//将产生中间（CALL，。。。。。。。。。。）代码函数压栈
}


void dealpro[/* 78 */](			)
{
	E++;//E记录参数个数 
	//将产生中间代码(VALACT/VARACT,................)函数压栈 函数必须功能：判断语义栈对应ARG是 值参 还是 形参
}


////////////////////////////////////////////////EXP 算数表达式处理函数 ////////////////////////////////////////
/////////////////////////////////////之 +
void dealpro[/* 101  */](			)
{
	//将产生中间代码（ADD，。。。。。。。。。。）函数压栈
	//弹出当前语义栈栈顶两个元素
}

/////////////////////////////////////之 -
void dealpro[/* 102 */](		)
{
	//同 101        (SUB,.......................)
}

////////////////////////////////////之 *
void dealpro[/*  103 */](		)
{
	//              (MULTI,..............）
}

////////////////////////////////////之 /
 void dealpro[/*  104    */](		)
{
	//		(除，。。。。。。。）
}

/////////////////////////////////////之 <
void dealpro[/*  99 */](		)
{
	//		(!!!!查！！小于？，。。。。）
}

///////////////////////////////////之 =
{
	//           (！！！小于？,....................)
}
/////////////////////////////////////////////////输入语句          ///////////////////////////////////////////
void dealpro[/*72*/]()
{
	//产生中间代码(WRITEC,???,NUll,NULL)
}

////////////////////////////////////////////////输出语句        ////////////////////////////////////////
void dealpro[/*74*/]()
{
	//将产生语句（WRIGEC，。。。。。。）函数压栈
}




void dealpro[/* 73 */]()
{
	//调用ID压栈函数
	//设置向后处理函数标记。
}


//////////////////////////////////////////////////////过程申明函数   ///////////////////////////





////////////////////////////////////////////////////ID存表 函数//////////////////////////



///////////////////////////////////////////////////ID 查表函数
